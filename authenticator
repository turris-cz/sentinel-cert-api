#!/usr/bin/env python
import redis
from flask import Flask
from flask import request
from flask import jsonify
import json
from OpenSSL import crypto
import argparse
import random
import logging

DELAY_GET_SESSION_EXISTS = 10
DELAY_AUTH = 10
DELAY_AUTH_AGAIN = 10
app = Flask(__name__)


def get_arg_parser():
    parser = argparse.ArgumentParser(
            description='Sentinel:cert-api'
    )
    parser.add_argument(
        '--redis-port',
        nargs=1,
        type=int,
        help='redis port',
        required=True
    )
    parser.add_argument(
        '--redis-address',
        nargs=1,
        help='redis ip address',
        required=True
    )
    parser.add_argument(
        '--console-log',
        type=int,
        choices=range(1, 51),
        help='Enables logging to console for the level 1..50'
    )
    return parser


@app.route("/", methods=['GET'])
def hello_world():
    return "Hello World"


@app.route("/", methods=['POST'])
def process_all():
    # request.data is class bytes
    req_json = request.get_json()  # class dict

    root_logger.debug("Incomming connection:\n{}".format(
        json.dumps(req_json, indent=2)
    ))

    if not req_json.get('sn'):
        print("sn not present")
        return jsonify({"status": "error"})

    if req_json.get('sid') is None:
        print("sid not present")
        return jsonify({"status": "error"})

    if not req_json.get('type'):
        print("type not present")
        return jsonify({"status": "error"})

    if not req_json.get("api_version"):
        print("api version not present")
        return jsonify({"status": "error"})

    if req_json['type'] == 'get_cert':

        if not req_json.get('csr'):
            print("csr not present")
            return jsonify({"status": "error"})

        return exec_state_get(
            req_json["sn"],
            req_json["sid"],
            req_json["csr"]
        )
        # TODO kontrola formatu sid, sn, csr

    elif req_json["type"] == "auth":
        return exec_state_auth(
            req_json["sn"],
            req_json["sid"],
            req_json["digest"],
        )


def get_nonce():
    # TODO vylepsit
    return str(random.randint(
        1000000000000000000000000000000000000000000000000000000000000000,
        9999999999999999999999999999999999999999999999999999999999999999
    ))


def exec_state_get(sn, sid, csr_str):
    root_logger.debug("exec_state_get")

    def cert_not_in_redis(sn, sid, csr_str):
        # cert with matching PKey not found in redis
        if r.exists((sn, sid)):  # cert creation in progress
            return jsonify({
                "status": "wait",
                "delay": DELAY_GET_SESSION_EXISTS
            })
        else:  # authenticate
            sid = random.randint(1, 10000000000)
            nonce = get_nonce()
            r.setnx((sn, sid), {
                "nonce": nonce,
                "digest": "",
                "csr_str": csr_str,
            })
            return jsonify({
                "status": "authenticate",
                "sid": sid,
                "nonce": nonce,
            })

    csr = crypto.load_certificate_request(
        type=crypto.FILETYPE_PEM,
        buffer=csr_str
    )

    csr_pubkey_str = crypto.dump_publickey(
        type=crypto.FILETYPE_PEM,
        pkey=csr.get_pubkey()
    ).decode("utf-8")

    if r.exists(sn):  # cert for requested sn is already in redis
        cert_str = r.get(sn).decode("utf-8")
        print("cert z redisu------")
        print(type(cert_str))
        print(cert_str)
        cert = crypto.load_certificate(
            type=crypto.FILETYPE_PEM,
            buffer=cert_str
        )
        cert_pubkey_str = crypto.dump_publickey(
            type=crypto.FILETYPE_PEM,
            pkey=cert.get_pubkey()
        ).decode("utf-8")

        # cert and csr public key match
        print("csr public key")
        print(csr_pubkey_str)
        print("cert public key")
        print(cert_pubkey_str)
        if (csr_pubkey_str == cert_pubkey_str):
            print("vydavam ulozeny cert")
            return jsonify({
                "status": "ok",
                "cert": cert_str
            })

        else:
            print("generuji novy cert - pkey does not match")
            return cert_not_in_redis(sn, sid, csr_str)
    else:
        print("cert not in redis, auth")
        return cert_not_in_redis(sn, sid, csr_str)


def exec_state_auth(sn, sid, digest):
    root_logger.debug("exec_state_auth")
    if r.exists((sn, sid)):  # cert for requested sn is already in redis
        session_json = json.loads(
            r.get((sn, sid)).decode("utf-8").replace("'", '"')
        )
        print("+-+-+-+--+-+")
        print(type(session_json))
        print(session_json)
        print("+-+-+-+-+-+-")
        if session_json["digest"]:
            if session_json["digest"] == digest:
                return jsonify({
                    "status": "accepted",
                    "delay": DELAY_AUTH_AGAIN,
                })
            else:
                print("re-auth: digest does not match")
                return jsonify({"status": "error"})
        else:
            session_json["digest"] = digest
            # lze v redisu atomicky? asi ne...
            r.delete((sn, sid))
            r.setnx((sn, sid), session_json)
            r.lpush('csr', {
                "sn": sn,
                "sid": sid,
                "nonce": session_json['nonce'],
                "digest": digest,
                "csr_str": session_json['csr_str'],
            })

    # do tohohle jsonu zapisuju typy class str a class int
    # take prida application/json mimetype
    # print(str(responses))
    return jsonify({
        "status": "accepted",
        "delay": DELAY_AUTH,
    })


if __name__ == "__main__":
    root_logger = logging.getLogger()
    root_logger.setLevel('DEBUG')
    root_logger.addHandler(logging.NullHandler())

    parser = get_arg_parser()
    args = parser.parse_args()

    if args.console_log:
        cl = logging.StreamHandler()
        cl.setLevel(args.console_log)
        cl.formatter = logging.Formatter('%(levelname)s:%(message)s')
        root_logger.addHandler(cl)

    r = redis.StrictRedis(
        host=args.redis_address[0],
        port=args.redis_port[0],
        db=0
    )

    app.run(
        host='0.0.0.0',
        ssl_context=(
            'server.pem',
            'server.key'
        )
    )
